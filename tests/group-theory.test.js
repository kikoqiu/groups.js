import { PermutationSet, generateGroup } from '../src/group-engine.js';
import { globalRepo } from '../src/permutation-repository.js';

// ============================================================================
// Test Helpers
// ============================================================================

// Helper to quickly create a group from raw permutation arrays
const createGroup = (perms) => {
    const ids = perms.map(p => globalRepo.register(p));
    // Create a temporary set and generate the full group to ensure closure
    const genSet = new PermutationSet(ids);
    return generateGroup(genSet);
};

// Helper to register a single perm and get ID
const reg = (p) => globalRepo.register(p);

// ============================================================================
// Test Suite
// ============================================================================

describe('PermutationSet', () => {
    
    // Standard Groups for reuse
    let S3, V4, C4, Identity;
    let id_e, id_r1, id_r2, id_f1, id_f2, id_f3;

    beforeAll(() => {
        // --- 1. Define S3 (Symmetric Group on 3 elements) ---
        // Degree = 3
        const p_e  = [0, 1, 2];
        const p_r1 = [1, 2, 0]; // (0 1 2)
        const p_r2 = [2, 0, 1]; // (0 2 1)
        const p_f1 = [0, 2, 1]; // (1 2)
        const p_f2 = [2, 1, 0]; // (0 2)
        const p_f3 = [1, 0, 2]; // (0 1)

        id_e  = reg(p_e);
        id_r1 = reg(p_r1);
        id_r2 = reg(p_r2);
        id_f1 = reg(p_f1);
        id_f2 = reg(p_f2);
        id_f3 = reg(p_f3);

        // Generate S3 from generators <r1, f1>
        S3 = generateGroup(new PermutationSet([id_r1, id_f1]));

        // --- 2. Define V4 (Klein Four Group) ---
        // Degree = 4. Abelian. Elements: e, (0 1)(2 3), (0 2)(1 3), (0 3)(1 2)
        const v4_gen1 = [1, 0, 3, 2]; // (0 1)(2 3)
        const v4_gen2 = [2, 3, 0, 1]; // (0 2)(1 3)
        V4 = createGroup([v4_gen1, v4_gen2]);

        // --- 3. Define C4 (Cyclic Group order 4) ---
        // Degree = 4. Generated by (0 1 2 3)
        const c4_gen = [1, 2, 3, 0]; 
        C4 = createGroup([c4_gen]);

        // --- 4. Identity Group ---
        Identity = PermutationSet.identity();
    });

    describe('Core Group Generation (Optimized)', () => {
        
        test('should generate full S3 (order 6) from rotation and flip', () => {
            expect(S3.size).toBe(6);
            expect(S3.isGroup).toBe(true);
            
            // Check membership of specific known IDs
            const indices = S3.indices;
            expect(indices).toContain(id_e);
            expect(indices).toContain(id_r1);
            expect(indices).toContain(id_f3); // Generated element
        });

        test('should generate A3 (Alternating Group, order 3) from 3-cycle', () => {
            const A3 = createGroup([[1, 2, 0]]); // <(0 1 2)>
            expect(A3.size).toBe(3);
            expect(A3.indices).toContain(id_r1);
            expect(A3.indices).toContain(id_r2);
            expect(A3.indices).toContain(id_e);
        });

        test('should generate trivial group from empty input', () => {
            const emptyGen = new PermutationSet([]);
            const G = generateGroup(emptyGen);
            expect(G.size).toBe(1);
            expect(G.indices[0]).toBe(id_e);
        });
    });

    describe('Right Coset Decomposition', () => {
        let A3, H_f1;

        beforeAll(() => {
            A3 = createGroup([[1, 2, 0]]); 
            H_f1 = createGroup([[0, 2, 1]]);
        });

        test('should decompose S3 by A3 into 2 cosets', () => {
            const cosets = S3.rightCosetDecomposition(A3);
            expect(cosets.length).toBe(2);
            
            // Coset sizes must be equal to subgroup size
            expect(cosets[0].size).toBe(3);
            expect(cosets[1].size).toBe(3);

            // Union of cosets must be S3
            const union = cosets[0].union(cosets[1]);
            expect(union.size).toBe(6);
        });

        test('should decompose S3 by H_f1 into 3 cosets', () => {
            const cosets = S3.rightCosetDecomposition(H_f1);
            expect(cosets.length).toBe(3);
            cosets.forEach(c => expect(c.size).toBe(2));
        });

        test('should handle decomposition by Identity (cosets = elements)', () => {
            const cosets = S3.rightCosetDecomposition(Identity);
            expect(cosets.length).toBe(6);
            expect(cosets[0].size).toBe(1);
        });

        test('should throw error if H is larger than G', () => {
            // A3 is order 3. S3 is order 6.
            expect(() => A3.rightCosetDecomposition(S3)).toThrow();
        });
    });

    // ========================================================================
    // NEW TESTS: isAbelian (Commutativity Check)
    // ========================================================================
    
    describe('isAbelian()', () => {
        
        test('1. Trivial group {e} is Abelian', () => {
            expect(Identity.isAbelian()).toBe(true);
        });

        test('2. Cyclic group C4 is Abelian', () => {
            // C4 = {e, r, r^2, r^3}. All cyclic groups are Abelian.
            expect(C4.size).toBe(4);
            expect(C4.isAbelian()).toBe(true);
        });

        test('3. Klein Four Group (V4) is Abelian', () => {
            // V4 ~ C2 x C2. Commutative but not cyclic.
            expect(V4.size).toBe(4);
            expect(V4.isAbelian()).toBe(true);
        });

        test('4. Symmetric Group S3 is Non-Abelian', () => {
            // Smallest non-abelian group. r*f != f*r
            expect(S3.size).toBe(6);
            expect(S3.isAbelian()).toBe(false);
        });

        test('5. Alternating Group A3 is Abelian', () => {
            // A3 is cyclic C3, so it is Abelian.
            const A3 = createGroup([[1, 2, 0]]);
            expect(A3.isAbelian()).toBe(true);
        });

        test('6. Single Generator Group is always Abelian', () => {
            // Generate a group from a random permutation
            const randomPerm = [1, 0, 3, 2, 5, 4]; // (0 1)(2 3)(4 5)
            const G = createGroup([randomPerm]);
            expect(G.isAbelian()).toBe(true);
        });

        test('7. Subgroup of Abelian Group is Abelian', () => {
            // C2 subgroup inside C4
            // C4 gen is [1, 2, 3, 0] (cycle). C4^2 is [2, 3, 0, 1] (double swap)
            const subC4 = createGroup([[2, 3, 0, 1]]);
            expect(C4.isAbelian()).toBe(true);
            expect(subC4.isAbelian()).toBe(true);
        });

        test('8. Non-Abelian Check: S4 Subset (Generated by (0 1) and (1 2))', () => {
            // Generates S3 embedded in S4 (on 0,1,2, fixed 3)
            const s3_embedded = createGroup([
                [1, 0, 2, 3], // (0 1)
                [0, 2, 1, 3]  // (1 2)
            ]);
            expect(s3_embedded.size).toBe(6);
            expect(s3_embedded.isAbelian()).toBe(false);
        });

        test('9. Empty set (degenerate case) is technically Abelian', () => {
            // Though usually not a group, the loop logic should return true (vacuously true)
            const empty = new PermutationSet([], true, false);
            expect(empty.isAbelian()).toBe(true);
        });
    });

    // ========================================================================
    // NEW TESTS: calculateOrbit (Orbit Calculation)
    // ========================================================================

    describe('calculateOrbit()', () => {
        let S3_4; // S3 acting on 4 points (point 3 is fixed)

        beforeAll(() => {
            // S3 generators extended to 4 points: (0 1 2)(3) and (0 1)(2)(3)
            S3_4 = createGroup([
                [1, 2, 0, 3], 
                [1, 0, 2, 3]
            ]);
        });

        test('10. Identity Group: Orbit is single point {p}', () => {
            const orbit0 = Identity.calculateOrbit(0);
            expect(orbit0).toEqual(new Int32Array([0]));
            
            const orbit5 = Identity.calculateOrbit(5); // Even if degree is smaller, identity is implicit
            expect(orbit5).toEqual(new Int32Array([5]));
        });

        test('11. Transitive Action: Orbit of 0 under S3 is {0, 1, 2}', () => {
            const orbit = S3.calculateOrbit(0);
            // Result must be sorted Int32Array
            expect(orbit).toEqual(new Int32Array([0, 1, 2]));
        });

        test('12. Transitive Action: Orbit of 1 under S3 is {0, 1, 2}', () => {
            const orbit = S3.calculateOrbit(1);
            expect(orbit).toEqual(new Int32Array([0, 1, 2]));
        });

        test('13. Fixed Point: Orbit of fixed point is {p}', () => {
            // In S3_4, point 3 is fixed by all elements
            const orbit = S3_4.calculateOrbit(3);
            expect(orbit).toEqual(new Int32Array([3]));
        });

        test('14. Disjoint Cycles: Action of (0 1)(2 3)', () => {
            const G = createGroup([[1, 0, 3, 2]]); // (0 1)(2 3)
            
            const orbit0 = G.calculateOrbit(0);
            expect(orbit0).toEqual(new Int32Array([0, 1]));
            
            const orbit2 = G.calculateOrbit(2);
            expect(orbit2).toEqual(new Int32Array([2, 3]));
        });

        test('15. Stabilizer Subgroup Orbit', () => {
            // Stabilizer of 2 in S3 is <(0 1)> = {e, (0 1)}
            const Stab2 = createGroup([[1, 0, 2]]);
            
            // Acting on 2 -> Fixed
            expect(Stab2.calculateOrbit(2)).toEqual(new Int32Array([2]));
            // Acting on 0 -> Swaps with 1
            expect(Stab2.calculateOrbit(0)).toEqual(new Int32Array([0, 1]));
        });

        test('16. Error Checking: Negative Point', () => {
            expect(() => S3.calculateOrbit(-1)).toThrow();
        });

        test('17. Error Checking: Point >= Degree', () => {
            // globalDegree expands dynamically, but let's try a huge number
            const hugePoint = globalRepo.globalDegree + 100;
            expect(() => S3.calculateOrbit(hugePoint)).toThrow();
        });
    });

    // ========================================================================
    // NEW TESTS: isGroup Flag Logic
    // ========================================================================

    describe('isGroup Flag Maintenance', () => {
        
        test('18. generateGroup() sets isGroup = true', () => {
            const G = generateGroup(new PermutationSet([id_r1]));
            expect(G.isGroup).toBe(true);
        });

        test('19. Identity factory sets isGroup = true', () => {
            const I = PermutationSet.identity();
            expect(I.isGroup).toBe(true);
        });

        test('20. Raw Union results default to isGroup = false', () => {
            // Union of two subgroups is rarely a group (unless one contains other)
            const Stab0 = createGroup([[0, 2, 1]]); // <(1 2)> fixes 0
            const Stab1 = createGroup([[2, 1, 0]]); // <(0 2)> fixes 1
            
            // The union contains {e, (1 2), (0 2)}. 
            // This is NOT a group because (1 2)*(0 2) = (0 1 2) which is missing.
            const unionSet = Stab0.union(Stab1);
            
            expect(unionSet.size).toBe(3);
            expect(unionSet.isGroup).toBe(false);
        });
    });

});