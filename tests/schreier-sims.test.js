import { SchreierSimsAlgorithm } from '../src/schreier-sims.js';
import { PermutationSet } from '../src/group-engine.js';
import { globalRepo } from '../src/permutation-repository.js';
import { createSymmetric, createCyclic, createFromCycleStrings } from '../src/group-utils.js';


// ============================================================================
// Test Helpers
// ============================================================================

/**
 * Creates a raw permutation array for a cycle (0 1 ... k-1) of length k in degree n.
 * Example: createCycle(3, 3) -> [1, 2, 0]
 * Example: createCycle(3, 5) -> [1, 2, 0, 3, 4]
 */
const createCycle = (k, n) => {
    const arr = new Int32Array(n);
    for (let i = 0; i < n; i++) arr[i] = i;
    for (let i = 0; i < k; i++) {
        arr[i] = (i + 1) % k;
    }
    return arr;
};

/**
 * Creates a raw permutation array swapping a and b in degree n.
 */
const createSwap = (a, b, n) => {
    const arr = new Int32Array(n);
    for (let i = 0; i < n; i++) arr[i] = i;
    arr[a] = b;
    arr[b] = a;
    return arr;
};

/**
 * Helper to compute BSGS from a list of raw arrays.
 */
const computeBSGS = (permArrays) => {
    const ids = permArrays.map(p => globalRepo.register(p));
    const groupSet = new PermutationSet(ids);
    return SchreierSimsAlgorithm.compute(groupSet);
};

// ============================================================================
// Advanced Test Suite
// ============================================================================

describe('SchreierSimsAlgorithm (Advanced Tests)', () => {

    describe('1. Fundamental Groups & Orders', () => {
        
        test('1. Identity Group: Order must be 1', () => {
            const algo = computeBSGS([]);
            expect(algo.order).toBe(1n);
            expect(algo.contains([0, 1, 2])).toBe(true);
        });

        test('2. Cyclic Group C10: Generated by (0..9)', () => {
            const n = 10;
            const cycle = createCycle(n, n);
            const algo = computeBSGS([cycle]);
            expect(algo.order).toBe(10n);
            expect(algo.contains(cycle)).toBe(true);
        });

        test('3. Klein Four Group (V4): Order 4', () => {
            // V4 = {e, (0 1)(2 3), (0 2)(1 3), (0 3)(1 2)}
            const a = [1, 0, 3, 2];
            const b = [2, 3, 0, 1];
            const algo = computeBSGS([a, b]);
            expect(algo.order).toBe(4n);
        });

        test('4. Symmetric Group S3: Order 6', () => {
            const r = createCycle(3, 3);
            const f = createSwap(0, 1, 3);
            const algo = computeBSGS([r, f]);
            expect(algo.order).toBe(6n);
        });

        test('5. Symmetric Group S4: Order 24', () => {
            // Generated by (0 1) and (0 1 2 3)
            const cycle = createCycle(4, 4); // (0 1 2 3)
            const swap = createSwap(0, 1, 4); // (0 1)
            const algo = computeBSGS([cycle, swap]);
            expect(algo.order).toBe(24n);
        });

        test('6. Symmetric Group S5: Order 120', () => {
            const cycle = createCycle(5, 5);
            const swap = createSwap(0, 1, 5);
            const algo = computeBSGS([cycle, swap]);
            expect(algo.order).toBe(120n);
        });

        test('7. Symmetric Group S6: Order 720', () => {
            const cycle = createCycle(6, 6);
            const swap = createSwap(0, 1, 6);
            const algo = computeBSGS([cycle, swap]);
            expect(algo.order).toBe(720n);
        });

        test('8. Alternating Group A4: Order 12', () => {
            // Generated by (0 1 2) and (1 2 3)? Or (0 1)(2 3) types.
            // A4 generators: (0 1 2) and (0 2 3)
            const a = [1, 2, 0, 3]; // (0 1 2)
            const b = [0, 2, 3, 1]; // (1 2 3)
            const algo = computeBSGS([a, b]);
            expect(algo.order).toBe(12n);
        });

        test('9. Alternating Group A5: Order 60 (Simple Group)', () => {
            // Generators for A5: (0 1 2) and (0 1 2 3 4) is S5? No.
            // A5 generated by (0 1 2) and (2 3 4) ???
            // Standard gens: (0 1 2) and (0 1)(2 3) no.
            // Let's use 3-cycles: (0 1 2) and (2 3 4) should generate A5 on 5 points?
            // Actually A_n is generated by (0 1 2), (1 2 3), ... 
            const g1 = [1, 2, 0, 3, 4]; // (0 1 2)
            const g2 = [0, 1, 3, 4, 2]; // (2 3 4)
            // Wait, (0 1 2) and (0 1 ... n) generates Sn if n is odd?
            // Reliable A5 gens: s=(0 1 2 3 4) is even? 5-cycle is even. t=(0 1)(2 3) is even.
            // <(0 1 2 3 4), (0 1)(2 3)> ?
            // Let's try:
            const s = [1, 2, 3, 4, 0]; // (0 1 2 3 4) even parity
            const t = [2, 3, 0, 1, 4]; // (0 2)(1 3) even parity
            
            // This specific pair might not be A5, let's verify Order.
            // Actually, <(0 1 2), (2 3 4)> generates A5?
            // Let's stick to reliable: A5 is generated by (0 1 2) and (0 1 2 3 4)? No, 5-cycle * 3-cycle.
            // Let's use: (0 1 2) and (0 1 2 3 4) is A5 if n is odd? 
            // (1 2 3) and (1 2 ... n) generates A_n if n is odd.
            // Here n=5 is odd. 
            const c3 = [1, 2, 0, 3, 4];
            const c5 = [1, 2, 3, 4, 0];
            const algo = computeBSGS([c3, c5]);
            expect(algo.order).toBe(60n);
        });
    });

    describe('2. Structure & Properties', () => {

        test('10. Disjoint Direct Product S3 x S3: Order 36', () => {
            // G1 acts on 0,1,2. G2 acts on 3,4,5.
            const r1 = [1, 2, 0, 3, 4, 5]; // (0 1 2)
            const f1 = [0, 2, 1, 3, 4, 5]; // (1 2)
            const r2 = [0, 1, 2, 4, 5, 3]; // (3 4 5)
            const f2 = [0, 1, 2, 3, 5, 4]; // (4 5)
            
            const algo = computeBSGS([r1, f1, r2, f2]);
            expect(algo.order).toBe(36n); // 6 * 6
        });

        test('11. Dihedral Group D4 (Symmetries of Square): Order 8', () => {
            // Permutations of vertices 0,1,2,3
            const rot = [1, 2, 3, 0]; // (0 1 2 3)
            const ref = [3, 2, 1, 0]; // (0 3)(1 2) reflection vertical
            const algo = computeBSGS([rot, ref]);
            expect(algo.order).toBe(8n);
        });

        test('12. Stabilizer Chain Correctness (Base Size)', () => {
            // For S6, base size should be at most 5 (usually 0,1,2,3,4)
            const cycle = createCycle(6, 6);
            const swap = createSwap(0, 1, 6);
            const algo = computeBSGS([cycle, swap]);
            
            expect(algo.base.length).toBeLessThanOrEqual(5);
            expect(algo.base.length).toBeGreaterThanOrEqual(1);
            
            // Transversal sizes should be 6, 5, 4, 3, 2
            const tSizes = algo.transversals.map(t => t.size).sort((a,b) => b-a);
            expect(tSizes).toEqual([6, 5, 4, 3, 2]);
        });
        
        test('13. Transversal Integrity', () => {
            // For S4, |G| = 24. Transversals typically sizes 4, 3, 2.
            // 4 * 3 * 2 * 1 = 24.
            const cycle = createCycle(4, 4);
            const swap = createSwap(0, 1, 4);
            const algo = computeBSGS([cycle, swap]);
            
            let calcOrder = 1;
            algo.transversals.forEach(t => calcOrder *= t.size);
            expect(BigInt(calcOrder)).toBe(24n);
        });
    });

    describe('3. Membership Testing', () => {
        let s4Algo;
        beforeAll(() => {
            const cycle = createCycle(4, 4);
            const swap = createSwap(0, 1, 4);
            s4Algo = computeBSGS([cycle, swap]);
        });

        test('14. Positive: Generator is Member', () => {
            const swap = createSwap(0, 1, 4);
            expect(s4Algo.contains(swap)).toBe(true);
        });

        test('15. Positive: Composite Element is Member', () => {
            // (0 1) * (0 1 2 3) = (0 2 3) ?
            // Let's manually create a valid permutation in S4
            const p = [1, 0, 3, 2]; // (0 1)(2 3)
            expect(s4Algo.contains(p)).toBe(true);
        });

        test('16. Negative: Element Outside Support', () => {
            // Permutation moving element 4 (which is outside S4 defined on 0..3)
            // But wait, createCycle(4,4) creates array length 4. 
            // If we check input length 5, behavior depends on implementation.
            // Let's create an input of matching length but acting on 'fixed' implicit point?
            // Actually, if we define S4 on indices 0..3 inside a degree 5 space:
            
            // Re-init S4 in degree 5
            const c = [1, 2, 3, 0, 4]; 
            const s = [1, 0, 2, 3, 4];
            const s4_in_5 = computeBSGS([c, s]);
            
            const outside = [0, 1, 2, 4, 3]; // (3 4) - moves point 4
            expect(s4_in_5.contains(outside)).toBe(false);
        });

        test('17. Negative: Odd Permutation in A4', () => {
            // A4 on 0..3. (0 1) is odd, should not be in A4.
            const a = [1, 2, 0, 3]; // (0 1 2)
            const b = [0, 2, 3, 1]; // (1 2 3)
            const a4 = computeBSGS([a, b]);
            
            const odd = [1, 0, 2, 3]; // (0 1)
            expect(a4.contains(odd)).toBe(false);
            expect(a4.order).toBe(12n);
        });

        test('18. Inverse Closure', () => {
            // If g in G, g^-1 in G
            const r = [1, 2, 3, 0];
            expect(s4Algo.contains(r)).toBe(true);
            
            // Inverse of (0 1 2 3) is (0 3 2 1) -> [3, 0, 1, 2]
            const rInv = [3, 0, 1, 2];
            expect(s4Algo.contains(rInv)).toBe(true);
        });
    });

    describe('4. Advanced Logic & Performance', () => {

        test('19. Large Degree Sparse Group (Iso S3)', () => {
            // S3 acting on 0,1,2 inside Degree 100
            const N = 100;
            const r = new Int32Array(N).map((_, i) => i);
            const f = new Int32Array(N).map((_, i) => i);
            
            // (0 1 2)
            r[0]=1; r[1]=2; r[2]=0;
            // (0 1)
            f[0]=1; f[1]=0;
            
            const algo = computeBSGS([r, f]);
            expect(algo.order).toBe(6n);
            expect(algo.degree).toBe(100);
        });

        test('20. Incremental Sifting (Adding Generators)', () => {
            // Start with C2 = <(0 1)>
            const swap = createSwap(0, 1, 3);
            const ids = [globalRepo.register(swap)];
            const set = new PermutationSet(ids);
            const algo = SchreierSimsAlgorithm.compute(set);
            
            expect(algo.order).toBe(2n);
            
            // Add (0 1 2) -> Should become S3 (Order 6)
            const rot = createCycle(3, 3);
            const rotId = globalRepo.register(rot);
            
            algo.siftAndInsert(rotId);
            expect(algo.order).toBe(6n);
        });

        test('21. Idempotency (Re-adding existing member)', () => {
            const cycle = createCycle(4, 4);
            const algo = computeBSGS([cycle]); // C4
            const initialOrder = algo.order;
            
            // Add cycle again
            algo.siftAndInsert(globalRepo.register(cycle));
            expect(algo.order).toBe(initialOrder);
            
            // Add identity
            algo.siftAndInsert(algo.idIdentity);
            expect(algo.order).toBe(initialOrder);
        });

        test('22. Commutator Subgroup Test', () => {
            // [x, y] = x^-1 y^-1 x y
            const cycle = createCycle(4, 4); // x
            const swap = createSwap(0, 1, 4); // y
            const algo = computeBSGS([cycle, swap]); // S4
            
            // Verify commutator is in G
            // S4 commutator subgroup is A4. 
            // Let's just check if the commutator of gens is contained.
            // We need to calculate [x, y] manually or trust contains logic.
            // Let's construct raw: 
            // x = (0 1 2 3), x' = (0 3 2 1)
            // y = (0 1), y' = (0 1)
            // x' y' x y 
            // Apply right to left (if repo func order) or left to right.
            // Let's just rely on contains returning true for any product.
            expect(algo.contains(cycle)).toBe(true);
        });

        test('23. Performance: S8 (Order 40,320)', () => {
            const start = performance.now();
            const cycle = createCycle(8, 8);
            const swap = createSwap(0, 1, 8);
            const algo = computeBSGS([cycle, swap]);
            const end = performance.now();
            
            expect(algo.order).toBe(40320n);
            // Should be reasonably fast (e.g., < 100ms usually, definitely < 1s)
            expect(end - start).toBeLessThan(1000); 
        });

        test('24. Random Walk Membership', () => {
            const cycle = createCycle(6, 6);
            const swap = createSwap(0, 1, 6);
            const algo = computeBSGS([cycle, swap]); // S6

            // Generate a random perm in S6 by multiplying gens randomly
            let current = new Int32Array(6).map((_, i) => i);
            let currentId = globalRepo.register(current);
            const genIds = [globalRepo.register(cycle), globalRepo.register(swap)];

            for(let i=0; i<50; i++) {
                const randGen = genIds[Math.floor(Math.random() * 2)];
                currentId = algo.multiply(currentId, randGen);
            }

            expect(algo.contains(currentId)).toBe(true);
        });

        test('25. Empty Group / Identity Only Input', () => {
            // Passing Identity explicitly
            const id = [0, 1, 2, 3];
            const algo = computeBSGS([id]);
            expect(algo.order).toBe(1n);
            expect(algo.contains(id)).toBe(true);
            
            // Passing empty array
            const algo2 = computeBSGS([]);
            expect(algo2.order).toBe(1n);
        });
    });
});





describe('SchreierSimsAlgorithm Extensions', () => {

    // Helper to ensure tests are isolated from globalRepo growth
    // by explicitly passing degrees to isTransitive.

    describe('isTransitive()', () => {
        test('S4 should be transitive on 4 points', () => {
            // S4 acts on 0,1,2,3
            const s4 = createSymmetric(4);
            const ssa = SchreierSimsAlgorithm.compute(s4);
            
            // Explicitly check transitivity on degree 4
            expect(ssa.isTransitive(4)).toBe(true);
            
            // If we check against a larger universe (e.g., 5), it should fail
            // because point 4 is fixed.
            expect(ssa.isTransitive(5)).toBe(false);
        });

        test('Cyclic Group C5 should be transitive on 5 points', () => {
            const c5 = createCyclic(5);
            const ssa = SchreierSimsAlgorithm.compute(c5);
            
            expect(ssa.isTransitive(5)).toBe(true);
        });

        test('Direct Product S2 x S2 acting on disjoint sets should NOT be transitive', () => {
            // Group 1: (0 1)
            // Group 2: (2 3)
            // Total points: 4. Orbits: {0,1}, {2,3}.
            const g = createFromCycleStrings(["(1 2)", "(3 4)"], 4);
            const ssa = SchreierSimsAlgorithm.compute(g);
            
            expect(ssa.isTransitive(4)).toBe(false);
            
            // Verify orbit size of 0 is 2
            expect(ssa.transversals[0].size).toBe(2);
        });

        test('Identity group should not be transitive on N > 1', () => {
            const s1 = createSymmetric(1); // Identity on 1 point (conceptually)
            // Register a larger perm to force repo expansion if needed, 
            // but we focus on the call to isTransitive
            const ssa = SchreierSimsAlgorithm.compute(s1);
            
            // Identity on 4 points is NOT transitive
            expect(ssa.isTransitive(4)).toBe(false);
            
            // Identity on 1 point IS transitive (trivially)
            expect(ssa.isTransitive(1)).toBe(true);
        });
    });

    describe('getStabilizer()', () => {
        test('Stabilizer of 0 in S3 should have order 2', () => {
            // S3 acting on 0,1,2. Order 6.
            const s3 = createSymmetric(3);
            const ssa = SchreierSimsAlgorithm.compute(s3);
            
            const stab0 = ssa.getStabilizer(0);
            
            // Convert stabilizer generators back to SSA to check order
            const stabSSA = SchreierSimsAlgorithm.compute(stab0);

            // |Stab(0)| = |G| / |Orbit(0)| = 6 / 3 = 2.
            expect(stabSSA.order).toBe(2n);
            
            // Verify all generators of stabilizer fix 0
            for (const id of stab0.indices) {
                const perm = globalRepo.get(id);
                // Permutation values are 0-based
                expect(perm[0]).toBe(0);
            }
        });

        test('Stabilizer of a point in A4: Orbit-Stabilizer Theorem', () => {
            // A4 acting on 0,1,2,3. Order 12. Transitive.
            // Note: createFromCycleStrings uses 1-based string input, so (1 2 3) -> 0->1->2->0.
            const a4 = createFromCycleStrings(["(1 2 3)", "(2 3 4)"], 4);
            const ssa = SchreierSimsAlgorithm.compute(a4);
            
            expect(ssa.order).toBe(12n);
            expect(ssa.isTransitive(4)).toBe(true);

            // Stabilizer of 0
            const stab = ssa.getStabilizer(0);
            const stabSSA = SchreierSimsAlgorithm.compute(stab);
            
            // Orbit size is 4. Expected Stabilizer size = 12 / 4 = 3.
            expect(stabSSA.order).toBe(3n);
            
            // Verify 0 is fixed
            for (const id of stab.indices) {
                const perm = globalRepo.get(id);
                expect(perm[0]).toBe(0);
            }
        });

        test('Stabilizer of a fixed point should be the whole group', () => {
            // Group generated by (0 1) acting on {0, 1, 2}.
            // Point 2 is fixed.
            // Input string "(1 2)" -> indices 0, 1 swapped. Index 2 fixed.
            const g = createFromCycleStrings(["(1 2)"], 3);
            const ssa = SchreierSimsAlgorithm.compute(g);
            
            expect(ssa.order).toBe(2n);

            const stab2 = ssa.getStabilizer(2);
            const stabSSA = SchreierSimsAlgorithm.compute(stab2);

            expect(stabSSA.order).toBe(2n); // Order unchanged
        });
    });
});