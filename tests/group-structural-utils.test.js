/**
 * @fileoverview Unit tests for Group Structural Utilities.
 * Tests cover subgroup checks, normality, closures, solvability, simplicity, 
 * quotient structures, and isomorphism heuristics.
 */

import {
    isSubgroup,
    isNormal,
    getNormalClosure,
    getCommutatorSubgroup,
    isSolvable,
    isSimple,
    getQuotientStructure,
    areIsomorphic,
    isNilpotent, 
    getLowerCentralSeries
} from '../src/group-structural-utils.js';

import {
    createQuaternion,
    createDirectProduct,
    createSymmetric,
    createAlternating,
    createCyclic,
    createKleinFour,
    createTrivial,
    createDihedral
} from '../src/group-utils.js';

import { globalRepo } from '../src/permutation-repository.js';
import { PermutationSet } from '../src/group-engine.js';
import { SchreierSimsAlgorithm } from '../src/schreier-sims.js';

describe('Group Structural Utilities', () => {

    // ========================================================================
    // 1. isSubgroup
    // ========================================================================
    describe('isSubgroup', () => {
        test('S3 should be a subgroup of S4', () => {
            const s4 = createSymmetric(4);
            const s3 = createSymmetric(3); // Acts on 0,1,2; fixes 3
            expect(isSubgroup(s4, s3)).toBe(true);
        });

        test('A3 should be a subgroup of S3', () => {
            const s3 = createSymmetric(3);
            const a3 = createAlternating(3);
            expect(isSubgroup(s3, a3)).toBe(true);
        });

        test('S4 should NOT be a subgroup of S3', () => {
            const s4 = createSymmetric(4);
            const s3 = createSymmetric(3);
            expect(isSubgroup(s3, s4)).toBe(false);
        });

        test('Trivial group should be a subgroup of any group', () => {
            const s4 = createSymmetric(4);
            const e = createTrivial();
            expect(isSubgroup(s4, e)).toBe(true);
        });

        test('Arbitrary distinct group check', () => {
            // C4 (0 1 2 3) vs V4 (0 1)(2 3), (0 2)(1 3)
            // V4 is not a subgroup of C4 (C4 has only one order 2 element)
            const c4 = createCyclic(4);
            const v4 = createKleinFour();
            expect(isSubgroup(c4, v4)).toBe(false);
        });
    });

    // ========================================================================
    // 2. isNormal
    // ========================================================================
    describe('isNormal', () => {
        test('A3 should be normal in S3', () => {
            const s3 = createSymmetric(3);
            const a3 = createAlternating(3);
            expect(isNormal(s3, a3)).toBe(true);
        });

        test('Klein Four (V4) should be normal in S4', () => {
            const s4 = createSymmetric(4);
            const v4 = createKleinFour();
            expect(isNormal(s4, v4)).toBe(true);
        });

        test('Subgroup generated by (1 2) should NOT be normal in S3', () => {
            const s3 = createSymmetric(3);
            // Generator (0 1) in 0-based index
            const swap = new Int32Array([1, 0, 2]);
            const sub = new PermutationSet([globalRepo.register(swap)]);
            expect(isNormal(s3, sub)).toBe(false);
        });

        test('S3 should NOT be normal in S4', () => {
            const s4 = createSymmetric(4);
            const s3 = createSymmetric(3);
            // S3 fixes point 4. Conjugating by (3 4) moves elements out of S3.
            expect(isNormal(s4, s3)).toBe(false);
        });

        test('Trivial group should be normal in S4', () => {
            const s4 = createSymmetric(4);
            const e = createTrivial();
            expect(isNormal(s4, e)).toBe(true);
        });
    });

    // ========================================================================
    // 3. getNormalClosure
    // ========================================================================
    describe('getNormalClosure', () => {
        test('Normal Closure of (1 2) in S3 should be S3', () => {
            // The normal closure of a transposition in Sn is Sn
            const s3 = createSymmetric(3);
            const swap = new Int32Array([1, 0, 2]); // (0 1)
            const closureSSA = getNormalClosure(s3, [globalRepo.register(swap)]);
            
            expect(closureSSA.order).toBe(6n); // |S3| = 6
        });

        test('Normal Closure of (1 2 3) in S3 should be A3', () => {
            // (1 2 3) generates A3, which is normal in S3. Closure is A3.
            const s3 = createSymmetric(3);
            const cycle3 = new Int32Array([1, 2, 0]); // (0 1 2)
            const closureSSA = getNormalClosure(s3, [globalRepo.register(cycle3)]);
            
            expect(closureSSA.order).toBe(3n); // |A3| = 3
        });

        test('Normal Closure of V4 generator in S4 should be V4', () => {
            const s4 = createSymmetric(4);
            // V4 gen: (0 1)(2 3)
            const doubleSwap = new Int32Array([1, 0, 3, 2]);
            const closureSSA = getNormalClosure(s4, [globalRepo.register(doubleSwap)]);
            
            expect(closureSSA.order).toBe(4n); // |V4| = 4
        });

        test('Normal Closure of trivial element should be trivial', () => {
            const s4 = createSymmetric(4);
            const closureSSA = getNormalClosure(s4, [globalRepo.identity]);
            expect(closureSSA.order).toBe(1n);
        });

        test('Normal Closure of (1 2) in S4 should be S4', () => {
            const s4 = createSymmetric(4);
            const swap = new Int32Array([1, 0, 2, 3]);
            const closureSSA = getNormalClosure(s4, [globalRepo.register(swap)]);
            expect(closureSSA.order).toBe(24n);
        });
    });

    // ========================================================================
    // 4. getCommutatorSubgroup
    // ========================================================================
    describe('getCommutatorSubgroup', () => {
        test('Commutator of S3 should be A3', () => {
            const s3 = createSymmetric(3);
            const derived = getCommutatorSubgroup(s3);
            expect(derived.order).toBe(3n);
        });

        test('Commutator of A4 should be V4', () => {
            const a4 = createAlternating(4);
            const derived = getCommutatorSubgroup(a4);
            expect(derived.order).toBe(4n); // V4 has order 4
        });

        test('Commutator of Abelian group (C4) should be Trivial', () => {
            const c4 = createCyclic(4);
            const derived = getCommutatorSubgroup(c4);
            expect(derived.order).toBe(1n);
        });

        test('Commutator of S4 should be A4', () => {
            const s4 = createSymmetric(4);
            const derived = getCommutatorSubgroup(s4);
            expect(derived.order).toBe(12n);
        });

        test('Commutator of V4 should be Trivial', () => {
            const v4 = createKleinFour();
            const derived = getCommutatorSubgroup(v4);
            expect(derived.order).toBe(1n);
        });
    });

    // ========================================================================
    // 5. isSolvable
    // ========================================================================
    describe('isSolvable', () => {
        test('S3 should be solvable', () => {
            expect(isSolvable(createSymmetric(3))).toBe(true);
        });

        test('S4 should be solvable', () => {
            // S4 > A4 > V4 > {e}
            expect(isSolvable(createSymmetric(4))).toBe(true);
        });

        test('A5 should NOT be solvable', () => {
            const a5 = createAlternating(5);
            expect(isSolvable(a5)).toBe(false);
        });

        test('Abelian groups (C5) should be solvable', () => {
            expect(isSolvable(createCyclic(5))).toBe(true);
        });

        test('Trivial group should be solvable', () => {
            expect(isSolvable(createTrivial())).toBe(true);
        });
    });

    // ========================================================================
    // 6. isSimple
    // ========================================================================
    describe('isSimple', () => {
        test('C5 (Prime Order) should be Simple (Return 1)', () => {
            const c5 = createCyclic(5);
            expect(isSimple(c5)).toBe(1);
        });

        test('C4 (Composite Order) should NOT be Simple (Return 0)', () => {
            const c4 = createCyclic(4); // Normal subgroup C2 exists
            expect(isSimple(c4)).toBe(0);
        });

        test('S3 should NOT be Simple (Return 0)', () => {
            const s3 = createSymmetric(3); // A3 is normal
            expect(isSimple(s3)).toBe(0);
        });

        test('S4 should NOT be Simple (Return 0)', () => {
            const s4 = createSymmetric(4); // A4 and V4 are normal
            expect(isSimple(s4)).toBe(0);
        });

        test('A5 should be Simple (Return -1 for Heuristically Yes)', () => {
            const a5 = createAlternating(5);
            // The heuristic checks normal closures of generators and random elements.
            // For A5, any non-trivial normal closure is A5.
            // So it shouldn't find any proper normal subgroups.
            expect(isSimple(a5)).toBe(-1); 
        });
    });

    // ========================================================================
    // 7. getQuotientStructure
    // ========================================================================
    describe('getQuotientStructure', () => {
        test('Quotient S3 / A3 should have order 2 (Isomorphic to C2)', () => {
            const s3 = createSymmetric(3);
            const a3 = createAlternating(3);
            
            const Q = getQuotientStructure(s3, a3);
            expect(Number(Q.size)).toBe(2);
            expect(Q.group.size).toBe(2);
        });

        test('Quotient A4 / V4 should have order 3 (Isomorphic to C3)', () => {
            const a4 = createAlternating(4);
            const v4 = createKleinFour();
            
            const Q = getQuotientStructure(a4, v4);
            expect(Number(Q.size)).toBe(3);
            expect(Q.group.size).toBe(3); // The permutation representation size
        });

        test('Quotient S4 / V4 should have order 6 (Isomorphic to S3)', () => {
            const s4 = createSymmetric(4);
            const v4 = createKleinFour();
            
            const Q = getQuotientStructure(s4, v4);
            expect(Number(Q.size)).toBe(6);
            expect(Q.group.size).toBe(6);
        });

        test('Lifting identity of quotient should give element in N', () => {
            const s3 = createSymmetric(3);
            const a3 = createAlternating(3);
            const Q = getQuotientStructure(s3, a3);

            // The identity of the quotient group acts on coset 0 -> 0.
            const idQuotient = globalRepo.identity;
            const lifted = Q.lift(idQuotient);
            
            // The lifted representative should be in A3 (or equivalent to identity coset)
            const ssaA3 = SchreierSimsAlgorithm.compute(a3);
            expect(ssaA3.contains(lifted)).toBe(true);
        });

        test('Should throw error if index is too large', () => {
            const s4 = createSymmetric(4);
            const e = createTrivial();
            // Index 24. If we set limit to 10...
            expect(() => {
                getQuotientStructure(s4, e, 10);
            }).toThrow();
        });
    });

    // ========================================================================
    // 8. areIsomorphic
    // ========================================================================
    describe('areIsomorphic', () => {
        test('S3 should be heuristically isomorphic to D3 (Return -1)', () => {
            const s3 = createSymmetric(3);
            const d3 = createDihedral(3); // D3 acting on 3 points is S3
            expect(areIsomorphic(s3, d3)).toBe(-1);
        });

        test('S3 should NOT be isomorphic to C6 (Return 0)', () => {
            const s3 = createSymmetric(3); // Non-Abelian
            const c6 = createCyclic(6);    // Abelian
            expect(areIsomorphic(s3, c6)).toBe(0);
        });

        test('A4 should NOT be isomorphic to S4 (Return 0)', () => {
            const a4 = createAlternating(4); // Order 12
            const s4 = createSymmetric(4);   // Order 24
            expect(areIsomorphic(a4, s4)).toBe(0);
        });

        test('S4 should NOT be isomorphic to S3 x S3 (Order 36) - check order', () => {
            // Mocking S3xS3 logic via order check
            // We don't have direct product in imports here easily without utils, 
            // but we can compare S4 with A5 (Order 60)
            const s4 = createSymmetric(4);
            const a5 = createAlternating(5);
            expect(areIsomorphic(s4, a5)).toBe(0);
        });

        test('C4 vs V4 (Both Abelian, Order 4) - Indistinguishable by current heuristics', () => {
            // Note: Current heuristics check Order, Abelian, Derived Series.
            // C4: Order 4, Ab, Derived len 1.
            // V4: Order 4, Ab, Derived len 1.
            // They might return -1 (Uncertain). Ideally should distinguish exponent, 
            // but code doesn't check exponent.
            const c4 = createCyclic(4);
            const v4 = createKleinFour();
            expect(areIsomorphic(c4, v4)).toBe(-1); 
        });
    });

});




describe('Group Structural Utils - Nilpotency', () => {
    
    // Clean up repo? Usually not needed for unit tests unless memory constrained,
    // but ensures isolation if repo state matters.
    // For these tests, repo persistence is fine.

    test('Symmetric Group S3 (Non-Nilpotent Solvable)', () => {
        // S3 order 6. Structure: S3 > A3 > {e}.
        // Derived series terminates (Solvable).
        // Lower Central Series: 
        // L0 = S3
        // L1 = [S3, S3] = A3
        // L2 = [A3, S3]. Since S3 non-abelian and A3 normal, [A3, S3] = A3.
        // Stays at A3. Not Nilpotent.
        
        const s3 = createSymmetric(3);
        
        // Basic Checks
        expect(isSolvable(s3)).toBe(true);
        
        // Nilpotency Check
        expect(isNilpotent(s3)).toBe(0);

        // Verify Series manually
        const lcs = getLowerCentralSeries(s3);
        // Expect [S3, A3, A3] or similar stabilization
        expect(lcs.length).toBeGreaterThanOrEqual(2);
        expect(lcs[0].order).toBe(6n); // S3
        expect(lcs[1].order).toBe(3n); // A3
        expect(lcs[lcs.length - 1].order).toBe(3n); // Stabilized at A3
    });

    test('Dihedral Group D4 (Nilpotent)', () => {
        // D4 (Symmetries of Square), Order 8.
        // D4 is a p-group (2-group), so it MUST be Nilpotent.
        // LCS: D4 > Z(D4) > {e}
        
        const d4 = createDihedral(4);
        
        expect(isSolvable(d4)).toBe(true);
        expect(isNilpotent(d4)).toBe(1);

        const lcs = getLowerCentralSeries(d4);
        // D4 (8) -> Commutator (2, which is Center) -> Identity (1)
        
        expect(lcs[0].order).toBe(8n);
        expect(lcs[lcs.length - 1].order).toBe(1n);
    });

    test('Cyclic Group C6 (Abelian => Nilpotent)', () => {
        // Abelian groups are always Nilpotent (Class 1).
        // [G, G] = {e}.
        
        const c6 = createCyclic(6);
        
        expect(isNilpotent(c6)).toBe(1);
        
        const lcs = getLowerCentralSeries(c6);
        expect(lcs[0].order).toBe(6n);
        expect(lcs[1].order).toBe(1n);
    });

    test('Trivial Group', () => {
        const e = createSymmetric(1); // Degree 1, Identity
        expect(isNilpotent(e)).toBe(1);
    });

    test('Alternating Group A4 (Non-Nilpotent)', () => {
        // A4 order 12. Solvable.
        // [A4, A4] = V4 (Klein 4).
        // [V4, A4] = V4.
        // Stays at V4. Not Nilpotent.
        
        const a4 = createAlternating(4);
        expect(isSolvable(a4)).toBe(true);
        expect(isNilpotent(a4)).toBe(0);
        
        const lcs = getLowerCentralSeries(a4);
        const last = lcs[lcs.length - 1];
        expect(last.order).toBe(4n); // V4
    });
});




describe('Group Structural Utils - Additional Cases', () => {

    test('Case 1: Quaternion Group Q8 (Nilpotent but Non-Abelian)', () => {
        // Q8 = {1, -1, i, -i, j, -j, k, -k}. Order 8.
        // It is a p-group (2-group), so it MUST be Nilpotent.
        // LCS: Q8 -> {1, -1} (Center) -> {1}
        const q8 = createQuaternion();

        expect(q8.isAbelian()).toBe(false);       // i*j != j*i
        expect(isSolvable(q8)).toBe(true);        // All p-groups are solvable
        expect(isNilpotent(q8)).toBe(1);          // All p-groups are nilpotent

        const lcs = getLowerCentralSeries(q8);
        expect(lcs[0].order).toBe(8n);
        expect(lcs[1].order).toBe(2n);            // The commutator subgroup is the center {-1, 1}
        expect(lcs[2].order).toBe(1n);            // Terminates
    });

    test('Case 2: Symmetric Group S4 (Solvable but Not Nilpotent)', () => {
        // S4 Order 24. 
        // Solvable: S4 > A4 > V4 > {e}
        // LCS: [S4, S4] = A4; [A4, S4] = A4. Stalls at A4.
        const s4 = createSymmetric(4);

        expect(isSolvable(s4)).toBe(true);
        expect(isNilpotent(s4)).toBe(0);

        const comm = getCommutatorSubgroup(s4);
        expect(comm.order).toBe(12n); // A4
    });

    test('Case 3: Direct Product S3 x C2 (Mixed Properties)', () => {
        // S3 is Not Nilpotent. C2 is Nilpotent.
        // Direct product is Nilpotent IFF both factors are Nilpotent.
        // So S3 x C2 should NOT be Nilpotent.
        const s3 = createSymmetric(3);
        const c2 = createCyclic(2);
        const product = createDirectProduct(s3, c2); // Order 12

        // product.size is the number of generators (2 from S3 + 1 from C2 = 3)
        expect(product.size).toBe(3); 
        
        // Use SSA to verify the mathematical Group Order
        const ssa = SchreierSimsAlgorithm.compute(product);
        expect(ssa.order).toBe(12n);

        expect(isNilpotent(product)).toBe(0);
        expect(isSolvable(product)).toBe(true); // Solvable x Solvable = Solvable
    });

    test('Case 4: Klein Four Group V4 (Abelian -> Nilpotent)', () => {
        // V4 is Abelian, so LCS terminates in 1 step: [G, G] = {e}
        const v4 = createKleinFour();

        expect(v4.isAbelian()).toBe(true);
        expect(isNilpotent(v4)).toBe(1);
        
        // Simplicity Check: V4 has normal subgroups (prop: {1, a}, {1, b}, {1, c})
        // So it is NOT simple.
        expect(isSimple(v4)).toBe(0); 
    });

    test('Case 5: Alternating Group A5 (Simple, Perfect, Non-Solvable)', () => {
        // A5 Order 60. The smallest non-abelian simple group.
        // Perfect: G' = G.
        const a5 = createAlternating(5);

        // 1. Not Solvable
        expect(isSolvable(a5)).toBe(false);

        // 2. Not Nilpotent (implies not Solvable)
        expect(isNilpotent(a5)).toBe(0);

        // 3. Perfect Group Check
        const derived = getCommutatorSubgroup(a5);
        expect(derived.order).toBe(60n); // Equal to original

        // 4. Simplicity Check
        // Our heuristic returns -1 for "Likely Simple" (Uncertain) when it can't find normal subgroups.
        // It should NOT return 0 (Proven Not Simple).
        const simplicityScore = isSimple(a5);
        expect(simplicityScore).not.toBe(0); 
        expect(simplicityScore).toBe(-1); 
    });

});