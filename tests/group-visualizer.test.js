import { globalRepo } from '../src/permutation-repository.js';
import { createSymmetric, createCyclic, createDihedral } from '../src/group-utils.js';
import { generateMultiplicationTable } from '../src/group-visualizer.js';

describe('GroupVisualizer Integration Tests', () => {

    // Helper to get raw array from PermSet
    const getIds = (set) => Array.from(set.indices);

    // ========================================================================
    // 1. Expansion Logic Tests (via generateMultiplicationTable)
    // ========================================================================

    test('1. Auto-Expand: Input Generators of S3 -> Output 6x6 Table', () => {
        // Create S3
        const s3 = createSymmetric(3);
        const allIds = getIds(s3); // Size 6
        
        // Pick just the generators (usually index 1 and 2 if sorted: swap and cycle)
        // Or filter out identity to simulate "user inputs generators"
        const generators = allIds.filter(id => id !== globalRepo.identity);
        
        // Pass ONLY generators
        const res = generateMultiplicationTable(generators);
        
        // Expect S3 size = 6
        expect(res.matrix.length).toBe(6);
        expect(res.grid.length).toBe(6);
        
        // Check content implies full group
        const names = res.grid.flat();
        expect(names).toContain('e'); // Identity recovered
        expect(names).toContain('a');
        expect(names).toContain('b'); // Assuming 2 gens
        // Should contain 36 cells
        expect(names.length).toBe(36);
    });

    test('2. Auto-Expand: Input Generators of C4 -> Output 4x4 Table', () => {
        const c4 = createCyclic(4);
        const generators = getIds(c4).filter(id => id !== globalRepo.identity);
        
        // Pass generators (should include a 4-cycle)
        const res = generateMultiplicationTable(generators);
        
        expect(res.matrix.length).toBe(4);
        
        // Check naming logic for cyclic
        const row0 = res.grid[0]; // e * G
        expect(row0).toContain('e');
        expect(row0).toContain('a');
        expect(row0).toContain('a^2');
        expect(row0).toContain('a^3');
    });

    test('3. Auto-Expand: Input Identity only -> Output 1x1 Table', () => {
        const id = globalRepo.identity;
        const res = generateMultiplicationTable([id]);
        
        expect(res.matrix.length).toBe(1);
        expect(res.grid[0][0]).toBe('e');
    });

    test('4. Auto-Expand: Redundant Generators input -> Cleaned 4x4 Table (C4)', () => {
        // C4 generated by (1 2 3 4).
        // Input: (1 2 3 4) AND (1 3)(2 4) [which is a^2]
        // Should detect redundancy, pick 1 generator, make 4x4 table.
        const p1 = globalRepo.register([1, 2, 3, 0]); // (1 2 3 4) - Generator
        const p2 = globalRepo.register([2, 3, 0, 1]); // (1 3)(2 4) - Redundant
        
        const res = generateMultiplicationTable([p1, p2]);
        
        expect(res.matrix.length).toBe(4);
        // Names should imply 1 generator ('a', 'a^2'...), not 'b'
        const allNames = res.grid.flat();
        expect(allNames.includes('b')).toBe(false); 
    });

    // ========================================================================
    // 2. Naming Logic Verification
    // ========================================================================

    test('5. Naming: S3 Generators mapped to a and b', () => {
        const s3 = createSymmetric(3);
        const gens = getIds(s3).filter(id => id !== globalRepo.identity);
        
        const res = generateMultiplicationTable(gens);
        
        // The headers
        const headers = res.grid[0]; // First row corresponds to e * Headers
        // Usually index 0 is e.
        expect(headers[0]).toBe('e');
        
        // Check for existence of basic generators
        const headerSet = new Set(headers);
        expect(headerSet.has('a')).toBe(true);
        expect(headerSet.has('b')).toBe(true);
    });

    test('6. Naming: Commutativity check in names (visual)', () => {
        // Klein 4 group: a, b, ab. Commutative, so ab = ba.
        // We simulate input generators for K4: (1 2)(3 4) and (1 3)(2 4)
        const k4g1 = globalRepo.register([1, 0, 3, 2]);
        const k4g2 = globalRepo.register([2, 3, 0, 1]);
        
        const res = generateMultiplicationTable([k4g1, k4g2]);
        
        expect(res.matrix.length).toBe(4);
        const flat = res.grid.flat();
        // Since we process BFS, we name 'ab'. 'ba' should map to the same ID.
        // The table should just use 'ab' consistently (or 'ba' consistently).
        // It should NOT have both if they are the same element.
        const hasAB = flat.includes('ab');
        const hasBA = flat.includes('ba');
        
        // Only one canonical name should exist for the compound element
        expect(hasAB !== hasBA).toBe(true); // XOR: one or the other, not both distinct names for same cell
        // Actually, BFS assigns one name to the ID. So the grid will only contain that one string.
    });

    test('d4', () => {        
        const res = generateMultiplicationTable(createDihedral(4));  
    });


    // ========================================================================
    // 4. Manual Mode (Backwards Compatibility / Exact Control)
    // ========================================================================

    test('8. Manual Mode: Does NOT expand if nameMap provided', () => {
        // If I pass just generators AND a map, it should respect the map and input list.
        const id = globalRepo.identity;
        const gen = globalRepo.register([1, 0]); // (1 2)
        
        const input = [id, gen];
        const map = new Map();
        map.set(id, 'Id');
        map.set(gen, 'Swap');
        
        const res = generateMultiplicationTable(input, map);
        
        // Should strictly be 2x2, even if these elements generate a larger group (they don't here, but logic holds)
        expect(res.matrix.length).toBe(2);
        expect(res.grid[0][0]).toBe('Id');
        expect(res.grid[0][1]).toBe('Swap');
    });

    test('9. Manual Mode: Throws on missing name', () => {
        const id = globalRepo.identity;
        const input = [id];
        const map = new Map(); // Empty map
        
        expect(() => {
            generateMultiplicationTable(input, map);
        }).toThrow(/Insufficient names/);
    });
});