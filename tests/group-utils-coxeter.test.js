import {
    createSymmetric, 
    createCyclic, 
    createDirectProduct, 
} from '../src/group-utils.js';
import {analyzeGenerators} from "../src/group-structural-utils.js"
import { globalRepo } from '../src/permutation-repository.js';
import { SchreierSimsAlgorithm } from '../src/schreier-sims.js';



import { findCoxeterLikeGenerators } from '../src/group-utils-coxeter.js';
import { createFromCycleStrings } from '../src/group-utils';
 // Helper: Verify the order of a group using SSA
const getOrder = (groupSet) => {
    const algo = SchreierSimsAlgorithm.compute(groupSet);
    return Number(algo.order);
};

// Helper: Check if a permutation is an involution (g^2 = e)
const isInvolution = (id) => {
    if (id === globalRepo.identity) return true;
    const sq = globalRepo.multiply(id, id);
    return sq === globalRepo.identity;
};

const isRedundant = (gens)=>{
    const analysis = analyzeGenerators(gens);
    return analysis.redundant.length>0;
}

describe('CoxeterGenerators', () => {

    // ========================================================================
    // 3. Coxeter / Heuristic Search Tests
    // ========================================================================

    test('findCoxeterLikeGenerators: S3 Decomposition', () => {
        // S3 (Order 6) standard gens might be (1 2) and (1 2 3).
        // We want findCoxeterLikeGenerators to find (1 2) and (2 3) [or (1 3)], which are involutions.
        const s3 = createSymmetric(3);
        
        const newGens = findCoxeterLikeGenerators(s3);
        let wanted=createFromCycleStrings(['(1 2)', '(2 3)']);
        expect(newGens.toString()).toEqual(wanted.toString());
        
        // 1. Check Order Preservation
        expect(getOrder(newGens)).toBe(6);
        expect(isRedundant(newGens)).toBe(false);
        
        // 2. Check Generators are Involutions (Order 2)
        // S3 is a Coxeter group, so it SHOULD be generated by involutions.
        for (const id of newGens.indices) {
            expect(isInvolution(id)).toBe(true);
        }
    });

    test('findCoxeterLikeGenerators: S4 (Symmetric Group on 4)', () => {
        // S4 Order 24. 
        const s4 = createSymmetric(4);
        const newGens = findCoxeterLikeGenerators(s4);

        let wanted=createFromCycleStrings(['(1 2)', '(2 3)', "(3 4)"]);
        expect(newGens.toString()).toEqual(wanted.toString());

        expect(getOrder(newGens)).toBe(24);
        expect(isRedundant(newGens)).toBe(false);
        
        // Verify sparsity/involutions
        // The heuristic prefers elements with low support (hamming distance).
        for (const id of newGens.indices) {
            const p = globalRepo.get(id);
            let support = 0;
            for(let i=0; i<p.length; i++) if(p[i]!==i) support++;
            
            // It should prefer transpositions (support 2) over double transpositions (support 4)
            // though not guaranteed, it's the target.
            // At minimum, they must be involutions.
            expect(isInvolution(id)).toBe(true);
        }
    });

    test('findCoxeterLikeGenerators: S5 (Symmetric Group on 5)', () => {
        const s4 = createSymmetric(4);
        const newGens = findCoxeterLikeGenerators(s4);
        
        expect(getOrder(newGens)).toBe(getOrder(s4));
        expect(isRedundant(newGens)).toBe(false);

        // Verify sparsity/involutions
        // The heuristic prefers elements with low support (hamming distance).
        for (const id of newGens.indices) {
            const p = globalRepo.get(id);
            let support = 0;
            for(let i=0; i<p.length; i++) if(p[i]!==i) support++;
                        
            expect(isInvolution(id)).toBe(true);
        }
    });


    test('findCoxeterLikeGenerators: Klein Four Group (V4)', () => {
        // All non-identity elements are order 2.
        // It's abelian, isomorphic to C2 x C2.
        // The algorithm should return 2 generators of order 2.
        const v4 = createDirectProduct(createCyclic(2), createCyclic(2)); // Acting on 4 points
        
        const newGens = findCoxeterLikeGenerators(v4);
        
        expect(getOrder(newGens)).toBe(4);
        expect(isRedundant(newGens)).toBe(false);

        expect(newGens.size).toBeGreaterThanOrEqual(2);
        
        // All generators must be order 2
        for(const id of newGens.indices) {
             expect(isInvolution(id)).toBe(true);
        }
    });

});