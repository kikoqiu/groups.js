import { SchreierSimsAlgorithm } from '../src/schreier-sims.js';
import { PermutationSet } from '../src/group-engine.js';
import { globalRepo } from '../src/permutation-repository.js';

// ============================================================================
// Test Helpers (Expanded)
// ============================================================================

const register = (p) => globalRepo.register(p);

const compute = (perms) => {
    const ids = perms.map(register);
    const groupSet = new PermutationSet(ids);
    return SchreierSimsAlgorithm.compute(groupSet);
};

// Creates a cycle (0 1 ... k-1) in a space of size n
const cycle = (k, n) => {
    const arr = new Int32Array(n).map((_, i) => i);
    for (let i = 0; i < k; i++) arr[i] = (i + 1) % k;
    return arr;
};

// Creates a swap (a b) in a space of size n
const swap = (a, b, n) => {
    const arr = new Int32Array(n).map((_, i) => i);
    arr[a] = b;
    arr[b] = a;
    return arr;
};

// Creates a shift permutation: map i -> i+1 mod k, but starting at offset
// e.g. shift(3, 10, 100) creates a 3-cycle on indices 10, 11, 12 inside degree 100
const offsetCycle = (k, offset, degree) => {
    const arr = new Int32Array(degree).map((_, i) => i);
    for (let i = 0; i < k; i++) {
        const curr = offset + i;
        const next = offset + ((i + 1) % k);
        arr[curr] = next;
    }
    return arr;
};

// ============================================================================
// Extended Test Suite
// ============================================================================

describe('SchreierSims Algorithm - Comprehensive Test Suite', () => {

    describe('1. Boundary & Trivial Cases', () => {
        
        test('1. Empty Input (Trivial Group)', () => {
            const algo = compute([]);
            expect(algo.order).toBe(1n);
            expect(algo.base.length).toBe(0);
        });

        test('2. Identity Only (Trivial Group)', () => {
            const id = new Int32Array([0, 1, 2, 3]);
            const algo = compute([id]);
            expect(algo.order).toBe(1n);
            expect(algo.contains(id)).toBe(true);
        });

        test('3. Single Involution (Order 2)', () => {
            const s = swap(0, 1, 5); // (0 1)
            const algo = compute([s]);
            expect(algo.order).toBe(2n);
        });

        test('4. Redundant Generators (Duplicates)', () => {
            const c = cycle(3, 3);
            const algo = compute([c, c, c]); // Inputting same gen multiple times
            expect(algo.order).toBe(3n);
        });

        test('5. Generators are Inverses', () => {
            const c = [1, 2, 0]; // (0 1 2)
            const c_inv = [2, 0, 1]; // (0 2 1)
            // Group generated by g and g^-1 is same as <g>
            const algo = compute([c, c_inv]); 
            expect(algo.order).toBe(3n);
        });
    });

    describe('2. Specific Group Families', () => {

        test('6. Cyclic Group C7 (Prime Order)', () => {
            const c7 = cycle(7, 7);
            const algo = compute([c7]);
            expect(algo.order).toBe(7n);
        });

        test('7. Dihedral Group D5 (Order 10)', () => {
            // D5 acting on 5 points. Generated by (0 1 2 3 4) and reflection (0 4)(1 3)
            const r = cycle(5, 5);
            const f = new Int32Array([4, 3, 2, 1, 0]); // (0 4)(1 3) fixes 2
            const algo = compute([r, f]);
            expect(algo.order).toBe(10n);
        });

        test('8. Dihedral Group D6 (Order 12)', () => {
            // D6 acting on 6 points
            const r = cycle(6, 6);
            const f = new Int32Array([0, 5, 4, 3, 2, 1]); // (1 5)(2 4) fixes 0,3
            const algo = compute([r, f]);
            expect(algo.order).toBe(12n);
        });

        test('9. Alternating Group A5 (Order 60)', () => {
            // Generated by (0 1 2) and (2 3 4) ? 
            // 3-cycles generate A_n.
            // (0 1 2) and (0 1 2 3 4) generates A5?
            // Let's use standard: S = (0 1 2 3 4), T = (0 1)(2 3) generates A5? No.
            // A5 Generators: (0 1 2) and (1 2 3 4 5) if n odd.
            const c3 = [1, 2, 0, 3, 4]; // (0 1 2)
            const c5 = [1, 2, 3, 4, 0]; // (0 1 2 3 4)
            const algo = compute([c3, c5]);
            // (0 1 2) is even. (0 1 2 3 4) is even.
            // <(0 1 2), (0 1 2 3 4)> = A5
            expect(algo.order).toBe(60n);
        });

        test('10. Direct Product S3 x S2 (Order 12)', () => {
            // S3 on 0,1,2. S2 on 3,4.
            const s3_gen1 = [1, 2, 0, 3, 4];
            const s3_gen2 = [1, 0, 2, 3, 4];
            const s2_gen  = [0, 1, 2, 4, 3]; // (3 4)
            const algo = compute([s3_gen1, s3_gen2, s2_gen]);
            expect(algo.order).toBe(12n);
        });
    });

    describe('3. Sparse & Disjoint Supports', () => {

        test('11. Disjoint Bases (S3 acting on 10,11,12)', () => {
            // Degree 20. Permutations only move 10,11,12.
            // Base should NOT start at 0.
            const r = offsetCycle(3, 10, 20); // (10 11 12)
            const f = new Int32Array(20).map((_, i) => i);
            // swap 10, 11
            f[10] = 11; f[11] = 10;
            
            const algo = compute([r, f]);
            expect(algo.order).toBe(6n);
            
            // Verify base picked up correct points
            // First moved point of r is 10.
            expect(algo.base[0]).toBe(10); 
        });

        test('12. Sparse Long Cycle (C2 on 0 and 99)', () => {
            const p = new Int32Array(100).map((_, i) => i);
            p[0] = 99; p[99] = 0;
            const algo = compute([p]);
            expect(algo.order).toBe(2n);
            // Base should be [0] (first moved point)
            expect(algo.base).toEqual([0]);
            // Transversal at level 0 should map 0->99 and 0->0
            expect(algo.transversals[0].has(99)).toBe(true);
        });

        test('13. Multi-Component Group (S3 on 0,1,2 AND S3 on 10,11,12)', () => {
            // Not direct product generators, but mixing them in one input list
            // G = <r1, f1, r2, f2>. Since supports disjoint, G = S3 x S3.
            const r1 = offsetCycle(3, 0, 20);
            const f1 = swap(0, 1, 20);
            const r2 = offsetCycle(3, 10, 20);
            const f2 = swap(10, 11, 20);

            const algo = compute([r1, f1, r2, f2]);
            expect(algo.order).toBe(36n); // 6 * 6
            // Base should handle both components (e.g., 0 and 10)
            expect(algo.base.includes(0)).toBe(true);
            expect(algo.base.includes(10)).toBe(true);
        });
    });

    describe('4. Incremental Construction & Dynamics', () => {

        test('14. Incremental: C3 -> S3', () => {
            const r = cycle(3, 3);
            const f = swap(0, 1, 3);
            
            // Start with C3
            const algo = compute([r]);
            expect(algo.order).toBe(3n);
            
            // Add flip to make S3
            algo.siftAndInsert(register(f));
            expect(algo.order).toBe(6n);
        });

        test('15. Incremental: S3 -> S4', () => {
            // Start with S3 on 0,1,2 (inside degree 4)
            const r = [1, 2, 0, 3];
            const f = [1, 0, 2, 3];
            const algo = compute([r, f]);
            expect(algo.order).toBe(6n);

            // Add (0 1 2 3) -> Generates S4
            const c4 = [1, 2, 3, 0];
            algo.siftAndInsert(register(c4));
            expect(algo.order).toBe(24n);
        });

        test('16. Degree Expansion Trigger', () => {
            // Start with S3 (degree 3)
            const algo = compute([cycle(3, 3), swap(0, 1, 3)]);
            expect(algo.degree).toBeGreaterThanOrEqual(3);

            // Create a permutation of degree 10
            const bigPerm = new Int32Array(10).map((_, i) => i);
            bigPerm[8] = 9; bigPerm[9] = 8; // Swap 8,9
            const bigId = globalRepo.register(bigPerm); // Triggers repo expansion

            // Insert into algorithm
            algo.siftAndInsert(bigId);
            
            // Algorithm should adapt to new degree and find new base point
            expect(algo.order).toBe(12n); // S3 x S2
            expect(algo.base).toContain(8); // Must pick up the new movement
            expect(algo.degree).toBeGreaterThanOrEqual(10);
        });
    });

    describe('5. Membership & Group Theory Checks', () => {
        let s4Algo;
        beforeAll(() => {
            s4Algo = compute([cycle(4, 4), swap(0, 1, 4)]); // S4
        });

        test('17. Subgroup Check: A4 is in S4', () => {
            const a4_gen1 = [1, 2, 0, 3]; // (0 1 2)
            const a4_gen2 = [0, 2, 3, 1]; // (1 2 3)
            expect(s4Algo.contains(a4_gen1)).toBe(true);
            expect(s4Algo.contains(a4_gen2)).toBe(true);
        });

        test('18. Non-Member Check: Odd Perm in A5', () => {
            // A5 on 5 points
            const a5 = compute([[1, 2, 0, 3, 4], [1, 2, 3, 4, 0]]);
            const odd = swap(0, 1, 5);
            expect(a5.contains(odd)).toBe(false);
        });

        test('19. Conjugate Stability (Normal Subgroup)', () => {
            // V4 normal in A4?
            // V4 = {e, (01)(23), (02)(13), (03)(12)}
            const v4_gen = [1, 0, 3, 2]; // (01)(23)
            const a4_elt = [1, 2, 0, 3]; // (012)
            
            const v4 = compute([v4_gen, [2, 3, 0, 1]]);
            
            // Note: This test checks logic manually. 
            // conjugate = a * v * a^-1. 
            // We just verify s4Algo (S4) contains the conjugate, which is trivial.
            // Better: Verify s4Algo contains commutator.
            expect(s4Algo.contains(v4_gen)).toBe(true);
        });

        test('20. Commutator Membership', () => {
            // [x, y] = x^-1 y^-1 x y
            // In S4, [ (01), (02) ] = (01)^-1 (02)^-1 (01) (02)
            // = (01)(02)(01)(02) = (12)(12)?? No.
            // (01)(02) = (0 1 2). (01)(02) again?
            // Let's rely on code.
            const x = swap(0, 1, 4);
            const y = swap(0, 2, 4);
            const xId = register(x);
            const yId = register(y);
            
            // Manually calc commutators: 
            // We expect the algorithm to confirm ANY combination of members is a member.
            // This implicitly tests _strip correctness.
            // Let's create a random product.
            let prod = s4Algo.idIdentity;
            prod = s4Algo.multiply(prod, xId);
            prod = s4Algo.multiply(prod, yId);
            prod = s4Algo.multiply(prod, xId);
            
            expect(s4Algo.contains(prod)).toBe(true);
        });
    });

    describe('6. Performance & Limits', () => {

        test('21. Performance: S7 Construction (Order 5040)', () => {
            const t0 = performance.now();
            const algo = compute([cycle(7, 7), swap(0, 1, 7)]);
            const t1 = performance.now();
            expect(algo.order).toBe(5040n);
            // Typical time < 20ms
            expect(t1 - t0).toBeLessThan(500); 
        });

        test('22. Performance: S8 Construction (Order 40320)', () => {
            const t0 = performance.now();
            const algo = compute([cycle(8, 8), swap(0, 1, 8)]);
            const t1 = performance.now();
            expect(algo.order).toBe(40320n);
            // Typical time < 100ms
            expect(t1 - t0).toBeLessThan(1000);
        });

        test('23. Large Group Order (S12)', () => {
            // Order 12! = 479,001,600.
            // Still fits in number, but we check BigInt return.
            const algo = compute([cycle(12, 12), swap(0, 1, 12)]);
            const order = algo.order;
            expect(typeof order).toBe('bigint');
            expect(order).toBe(479001600n);
        });

        test('24. Sifting Throughput (1000 ops)', () => {
            const algo = compute([cycle(5, 5), swap(0, 1, 5)]); // S5 order 120
            const p = register(swap(2, 3, 5)); // Member
            
            const t0 = performance.now();
            for(let i=0; i<1000; i++) {
                expect(algo.contains(p)).toBe(true);
            }
            const t1 = performance.now();
            // Should be instant
            expect(t1 - t0).toBeLessThan(200);
        });

        test('25. Random Subgroup of S10', () => {
            // Generate 2 random perms in S10
            const p1 = new Int32Array(10).map((_, i) => i);
            const p2 = new Int32Array(10).map((_, i) => i);
            // Fisher-Yates shuffle
            for (let i = 9; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [p1[i], p1[j]] = [p1[j], p1[i]];
            }
            for (let i = 9; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [p2[i], p2[j]] = [p2[j], p2[i]];
            }

            const algo = compute([p1, p2]);
            // Order should be > 1
            expect(algo.order > 1n).toBe(true);
            // Generators should be in group
            expect(algo.contains(p1)).toBe(true);
            expect(algo.contains(p2)).toBe(true);
        });
    });

    describe('7. Logic Internals', () => {

        test('26. Transitivity Check (Orbit Size)', () => {
            // S5 is transitive on 0..4. Orbit(0) should be size 5.
            const algo = compute([cycle(5, 5), swap(0, 1, 5)]);
            // Base 0 is likely 0 (first moved).
            // algo.transversals[0] is the orbit of base[0].
            const orbitSize = algo.transversals[0].size;
            expect(orbitSize).toBe(5);
        });

        test('27. Intransitive Group (S3 on 4 points, point 3 fixed)', () => {
            const r = [1, 2, 0, 3];
            const f = [1, 0, 2, 3];
            const algo = compute([r, f]);
            // Orbit of 0 is {0,1,2} size 3.
            expect(algo.transversals[0].size).toBe(3);
            
            // Orbit of 3? 3 is fixed.
            // If 3 is never chosen as base, we won't see it in transversals.
            // But we can verify contains([0,1,2,3]) is true.
            expect(algo.contains([0, 1, 2, 3])).toBe(true);
        });

        test('28. Base Selection Order', () => {
            // If we supply (0 1) last, does base pick 0 later?
            // Base picking depends on "First Moved Point" of sift residue.
            // 1. Add (2 3). Base: [2].
            // 2. Add (0 1). Base: [2, 0].
            const s23 = swap(2, 3, 4);
            const s01 = swap(0, 1, 4);
            
            const algo = compute([s23]); 
            expect(algo.base[0]).toBe(2);
            
            algo.siftAndInsert(register(s01));
            // Base should extend
            expect(algo.base.includes(0)).toBe(true);
        });

        test('29. Long Chain Stability (S10)', () => {
            // S10 has base length 9 (0..8).
            const algo = compute([cycle(10, 10), swap(0, 1, 10)]);
            expect(algo.base.length).toBe(9);
            // Verify chain sizes: 10, 9, 8, ... 2
            const sizes = algo.transversals.map(t => t.size);
            expect(sizes[0]).toBe(10); // Orbit of first base
        });

        test('30. Deep Sift Residue', () => {
            // Manually force a sift that goes deep.
            // In S10, check membership of (8 9).
            // Should fall through 0..7 and be caught at 8.
            const algo = compute([cycle(10, 10), swap(0, 1, 10)]);
            const deepSwap = swap(8, 9, 10);
            
            // This tests internal correctness of _strip loop
            expect(algo.contains(deepSwap)).toBe(true);
        });
    });
});