<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>group-utils-coxeter.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="PermutationRepository.html">PermutationRepository</a><ul class='methods'><li data-type='method'><a href="PermutationRepository.html#commutator">commutator</a></li><li data-type='method'><a href="PermutationRepository.html#conjugate">conjugate</a></li><li data-type='method'><a href="PermutationRepository.html#get">get</a></li><li data-type='method'><a href="PermutationRepository.html#getAsCycles">getAsCycles</a></li><li data-type='method'><a href="PermutationRepository.html#inverse">inverse</a></li><li data-type='method'><a href="PermutationRepository.html#multiply">multiply</a></li><li data-type='method'><a href="PermutationRepository.html#register">register</a></li></ul></li><li><a href="PermutationSet.html">PermutationSet</a><ul class='methods'><li data-type='method'><a href="PermutationSet.html#calculateOrbit">calculateOrbit</a></li><li data-type='method'><a href="PermutationSet.html#difference">difference</a></li><li data-type='method'><a href="PermutationSet.html#equals">equals</a></li><li data-type='method'><a href="PermutationSet.html#generateGroupFromThis">generateGroupFromThis</a></li><li data-type='method'><a href="PermutationSet.html#get">get</a></li><li data-type='method'><a href="PermutationSet.html#intersection">intersection</a></li><li data-type='method'><a href="PermutationSet.html#inverse">inverse</a></li><li data-type='method'><a href="PermutationSet.html#isAbelian">isAbelian</a></li><li data-type='method'><a href="PermutationSet.html#isSuperSetOf">isSuperSetOf</a></li><li data-type='method'><a href="PermutationSet.html#multiply">multiply</a></li><li data-type='method'><a href="PermutationSet.html#rightCosetDecomposition">rightCosetDecomposition</a></li><li data-type='method'><a href="PermutationSet.html#slice">slice</a></li><li data-type='method'><a href="PermutationSet.html#toString">toString</a></li><li data-type='method'><a href="PermutationSet.html#union">union</a></li><li data-type='method'><a href="PermutationSet.html#.identity">identity</a></li></ul></li><li><a href="QuotientGroupMap.html">QuotientGroupMap</a><ul class='methods'><li data-type='method'><a href="QuotientGroupMap.html#lift">lift</a></li></ul></li><li><a href="SchreierSimsAlgorithm.html">SchreierSimsAlgorithm</a><ul class='methods'><li data-type='method'><a href="SchreierSimsAlgorithm.html#contains">contains</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#getGeneratorsAsPermutationSet">getGeneratorsAsPermutationSet</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#getStabilizer">getStabilizer</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#isTransitive">isTransitive</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#siftAndInsert">siftAndInsert</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#toString">toString</a></li><li data-type='method'><a href="SchreierSimsAlgorithm.html#.compute">compute</a></li></ul></li><li><a href="VisualizerCayleyForceSimulator.html">VisualizerCayleyForceSimulator</a><ul class='methods'><li data-type='method'><a href="VisualizerCayleyForceSimulator.html#getPlotlyFrame">getPlotlyFrame</a></li><li data-type='method'><a href="VisualizerCayleyForceSimulator.html#tick">tick</a></li><li data-type='method'><a href="VisualizerCayleyForceSimulator.html#warmup">warmup</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="IntSetUtils.html">IntSetUtils</a><ul class='methods'><li data-type='method'><a href="IntSetUtils.html#.difference">difference</a></li><li data-type='method'><a href="IntSetUtils.html#.has">has</a></li><li data-type='method'><a href="IntSetUtils.html#.intersection">intersection</a></li><li data-type='method'><a href="IntSetUtils.html#.sortAndUnique">sortAndUnique</a></li><li data-type='method'><a href="IntSetUtils.html#.union">union</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#analyzeGenerators">analyzeGenerators</a></li><li><a href="global.html#areIsomorphic">areIsomorphic</a></li><li><a href="global.html#calcApproxOrder">calcApproxOrder</a></li><li><a href="global.html#createAlternating">createAlternating</a></li><li><a href="global.html#createCyclic">createCyclic</a></li><li><a href="global.html#createDihedral">createDihedral</a></li><li><a href="global.html#createDirectProduct">createDirectProduct</a></li><li><a href="global.html#createFromCycleStrings">createFromCycleStrings</a></li><li><a href="global.html#createFromRawArrays">createFromRawArrays</a></li><li><a href="global.html#createIcosahedral">createIcosahedral</a></li><li><a href="global.html#createKleinFour">createKleinFour</a></li><li><a href="global.html#createOctahedral">createOctahedral</a></li><li><a href="global.html#createQuaternion">createQuaternion</a></li><li><a href="global.html#createSymmetric">createSymmetric</a></li><li><a href="global.html#createTetrahedral">createTetrahedral</a></li><li><a href="global.html#createTrivial">createTrivial</a></li><li><a href="global.html#decomposeToCycles">decomposeToCycles</a></li><li><a href="global.html#findCoxeterLikeGenerators">findCoxeterLikeGenerators</a></li><li><a href="global.html#findLowOrderGenerators">findLowOrderGenerators</a></li><li><a href="global.html#generateCayleyGraphForPlotly">generateCayleyGraphForPlotly</a></li><li><a href="global.html#generateGroup">generateGroup</a></li><li><a href="global.html#generateMultiplicationTable">generateMultiplicationTable</a></li><li><a href="global.html#generateNames">generateNames</a></li><li><a href="global.html#getCommutatorSubgroup">getCommutatorSubgroup</a></li><li><a href="global.html#getLowerCentralSeries">getLowerCentralSeries</a></li><li><a href="global.html#getMixedCommutatorSubgroup">getMixedCommutatorSubgroup</a></li><li><a href="global.html#getNormalClosure">getNormalClosure</a></li><li><a href="global.html#getQuotientStructure">getQuotientStructure</a></li><li><a href="global.html#getSylowSubgroup">getSylowSubgroup</a></li><li><a href="global.html#globalRepo">globalRepo</a></li><li><a href="global.html#isNilpotent">isNilpotent</a></li><li><a href="global.html#isNormal">isNormal</a></li><li><a href="global.html#isSimple">isSimple</a></li><li><a href="global.html#isSolvable">isSolvable</a></li><li><a href="global.html#isSubgroup">isSubgroup</a></li><li><a href="global.html#parseCycles">parseCycles</a></li><li><a href="global.html#resetGlobalRepo">resetGlobalRepo</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">group-utils-coxeter.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Heuristic Search for Coxeter-like Generators.
 * 
 * This module attempts to reconstruct a "beautiful" generating set (Coxeter-like)
 * for a given permutation group. It prioritizes:
 * 1. Involutions (Order 2 elements).
 * 2. Sparsity (Low Hamming distance / Minimal support).
 * 3. Adjacency (Mapping point i to i+1).
 * 
 * ALGORITHM:
 * 1. Stabilizer Chain Decomposition: Break down the group into layers.
 * 2. Frontier Expansion: Greedily find generators to cover each layer's orbit.
 * 3. Safety Net: Verify if the found generators actually generate the full group.
 * 4. Minimization: Prune redundant generators, prioritizing the removal of "ugly" (high order) ones.
 */

import { globalRepo } from './permutation-repository.js';
import { PermutationSet } from './group-engine.js';
import { SchreierSimsAlgorithm } from './schreier-sims.js'; 
import { _lcm, calcApproxOrder } from './group-private-utils.js';

// ============================================================================
// Public API
// ============================================================================

/**
 * Attempts to find a set of generators that mimic a Coxeter system (strong generating set of involutions).
 * 
 * @param {PermutationSet|number[]} inputGenerators - The initial generators defining the group.
 * @param {{beamWidth:number, generations:number, forcedBase:number[]}} [options] - Configuration options.
 * @param {number} [options.beamWidth=50] - Number of candidates to keep in beam search.
 * @param {number} [options.generations=30] - Number of mixing generations.
 * @param {number[]} [options.forcedBase] - Force a specific base order.
 * @returns {PermutationSet} A new set of generators.
 */
export function findCoxeterLikeGenerators(inputGenerators, options = {}) {
    const { 
        beamWidth = 50,
        generations = 30,
        forcedBase = null
    } = options;

    const inputs = (inputGenerators instanceof PermutationSet) ? inputGenerators.indices : inputGenerators;
    
    // 0. Compute target group order for validation (Ground Truth)
    const targetSSA = SchreierSimsAlgorithm.compute(inputs);
    const targetOrder = targetSSA.order;

    // 1. Determine effective degree and base
    let maxPoint = 0;
    for (const id of inputs) {
        const perm = globalRepo.get(id);
        for (let i = perm.length - 1; i >= 0; i--) {
            if (perm[i] !== i) {
                if (i > maxPoint) maxPoint = i;
                break;
            }
        }
    }
    const degree = maxPoint + 1;
    const base = forcedBase || Array.from({ length: degree }, (_, i) => i);

    // 2. Build SSA to decompose the group structure layer by layer
    const ssa = new SchreierSimsAlgorithm(base);
    for (const id of inputs) {
        ssa.siftAndInsert(id);
    }

    // 3. Collect Candidate Generators (Greedy Frontier Expansion)
    const candidateGenerators = [];

    for (let i = 0; i &lt; ssa.base.length; i++) {
        const currentBasePoint = ssa.base[i];
        
        // Gather strong generators for G^(i) (Stabilizer of 0..i-1)
        const subGroupGenerators = [];
        for (let k = i; k &lt; ssa.generators.length; k++) {
            if (ssa.generators[k]) {
                for (const g of ssa.generators[k]) subGroupGenerators.push(g);
            }
        }

        if (subGroupGenerators.length === 0) continue;

        // Determine the full orbit of base[i] under G^(i)
        const fullOrbit = _computeOrbit(currentBasePoint, subGroupGenerators);
        if (fullOrbit.size === 1) continue;

        // Frontier Expansion Loop
        const levelGens = [];
        let coveredOrbit = new Set([currentBasePoint]);
        let loopSafety = 0;

        // Try to cover the entire orbit using heuristic search
        while (coveredOrbit.size &lt; fullOrbit.size &amp;&amp; loopSafety++ &lt; fullOrbit.size + 10) {
            
            const unvisited = new Set();
            for (const p of fullOrbit) {
                if (!coveredOrbit.has(p)) unvisited.add(p);
            }

            // Identify best (source, target) pair to bridge the gap.
            // Priority: Adjacent points (dist=1)
            let bestTargetPair = null;
            let minDist = Infinity;

            for (const u of coveredOrbit) {
                const candidates = [u + 1, u - 1];
                let foundAdj = false;
                for (const v of candidates) {
                    if (unvisited.has(v)) {
                        bestTargetPair = { u, v };
                        minDist = 1;
                        foundAdj = true;
                        break; 
                    }
                }
                if (foundAdj) break;

                if (minDist > 1) {
                    for (const v of unvisited) {
                        const d = Math.abs(u - v);
                        if (d &lt; minDist) {
                            minDist = d;
                            bestTargetPair = { u, v };
                        }
                    }
                }
            }

            if (!bestTargetPair) break;

            const { u: sourcePoint, v: targetPoint } = bestTargetPair;
            const singleTargetSet = new Set([targetPoint]);

            // A. Beam Search for "Nice" Generator (Involution)
            let bestGen = _beamSearchBestGenerator(
                subGroupGenerators, 
                sourcePoint, 
                singleTargetSet, 
                beamWidth, 
                generations
            );

            // B. Panic Mode: Random Walk for Involutions
            if (bestGen === -1) {
                bestGen = _randomWalkForInvolution(
                    subGroupGenerators, 
                    sourcePoint, 
                    singleTargetSet, 
                    2000 
                );
            }

            // C. Fallback: Any valid generator mapping u -> v (Even high order)
            if (bestGen === -1) {
                // Relax target to any unvisited if direct bridge failed
                bestGen = subGroupGenerators.find(id => {
                     const p = globalRepo.get(id);
                     const img = (sourcePoint &lt; p.length) ? p[sourcePoint] : sourcePoint;
                     return singleTargetSet.has(img); // Strict target check
                });
                
                // If strict target failed, look for ANY unvisited
                if (!bestGen) {
                    bestGen = subGroupGenerators.find(id => {
                         const p = globalRepo.get(id);
                         const img = (sourcePoint &lt; p.length) ? p[sourcePoint] : sourcePoint;
                         return unvisited.has(img);
                    });
                }
            }

            if (bestGen !== undefined &amp;&amp; bestGen !== -1) {
                levelGens.push(bestGen);
            } else {
                // If we are stuck, we break. The Safety Net will catch us.
                break;
            }

            coveredOrbit = _computeOrbit(currentBasePoint, levelGens);
        }
        
        candidateGenerators.push(...levelGens);
    }

    // 4. Safety Net: Verify Group Order
    // If the heuristic search missed elements (e.g., C4 case where involutions don't exist),
    // we MUST restore the original inputs to guarantee correctness.
    const checkSSA = SchreierSimsAlgorithm.compute(candidateGenerators);
    if (checkSSA.order &lt; targetOrder) {
        // We lost symmetry! Restore original generators.
        // The minimizer will clean up duplicates.
        candidateGenerators.push(...inputs);
    }

    // 5. Global Minimization (Pruning Phase)
    const minimalIds = _minimizeGenerators(candidateGenerators, targetOrder);

    return new PermutationSet(minimalIds, false, false);
}

// ============================================================================
// Internal Helpers
// ============================================================================

/**
 * Minimizes a set of generators while preserving the group order.
 * @private
 */
function _minimizeGenerators(genIds, targetOrder) {
    let currentSet = [...new Set(genIds)];
    
    // Sort to prioritize removing "Bad" generators first.
    // We want to KEEP: Order 2, Low Support, Small Displacement.
    // So we put "Bad" stuff at the START of the array to be removed first.
    currentSet.sort((a, b) => {
        const permA = globalRepo.get(a);
        const permB = globalRepo.get(b);
        const ordA = calcApproxOrder(permA);
        const ordB = calcApproxOrder(permB);
        
        // 1. High Order is BAD. (Desc order)
        if (ordA !== ordB) {
            // Special exception: Order 2 is Best.
            if (ordA === 2) return 1; // A is best, move to end
            if (ordB === 2) return -1; // B is best, move to end
            return ordB - ordA; // Otherwise remove largest order first
        }
        
        // 2. High Support is BAD.
        const suppA = _calculateSupport(permA);
        const suppB = _calculateSupport(permB);
        if (suppA !== suppB) return suppB - suppA;
        
        // 3. High Displacement is BAD.
        const dispA = _calculateDisplacement(permA);
        const dispB = _calculateDisplacement(permB);
        return dispB - dispA;
    });

    const workingSet = [...currentSet];
    const keptIndices = new Set(workingSet.map((_, i) => i));

    for (let i = 0; i &lt; workingSet.length; i++) {
        const testSetIds = [];
        for (let k = 0; k &lt; workingSet.length; k++) {
            if (k !== i &amp;&amp; keptIndices.has(k)) {
                testSetIds.push(workingSet[k]);
            }
        }

        // Verification
        const testSSA = SchreierSimsAlgorithm.compute(testSetIds);
        
        // Note: BigInt comparison
        if (testSSA.order === targetOrder) {
            keptIndices.delete(i); // Safe to remove
        }
    }

    return workingSet.filter((_, i) => keptIndices.has(i));
}

function _calculateSupport(perm) {
    let s = 0;
    for (let i = 0; i &lt; perm.length; i++) if (perm[i] !== i) s++;
    return s;
}

function _calculateDisplacement(perm) {
    let s = 0;
    for (let i = 0; i &lt; perm.length; i++) s += Math.abs(i - perm[i]);
    return s;
}

function _computeOrbit(startPoint, genIds) {
    const orbit = new Set([startPoint]);
    const queue = [startPoint];
    const perms = genIds.map(id => globalRepo.get(id));
    let ptr = 0;
    while(ptr &lt; queue.length) {
        const u = queue[ptr++];
        for(let i=0; i&lt;perms.length; i++) {
            const p = perms[i];
            const val = (u &lt; p.length) ? p[u] : u;
            if(!orbit.has(val)) {
                orbit.add(val);
                queue.push(val);
            }
        }
    }
    return orbit;
}

/**
 * Performs a Beam Search to find the "Canonical" generator.
 * @private
 */
function _beamSearchBestGenerator(genIds, sourcePoint, validDestinations, beamWidth, maxGenerations) {
    
    const evaluate = (id) => {
        const perm = globalRepo.get(id);
        const img = (sourcePoint &lt; perm.length) ? perm[sourcePoint] : sourcePoint;
        
        const isDestValid = validDestinations.has(img);
        const order = calcApproxOrder(perm);
        
        // 1. Must hit target
        if (!isDestValid) return 1e9; 

        // 2. Order 2 is critical
        const orderPenalty = (order === 2) ? 0 : (order * 1e5);

        // 3. Low Support
        const support = _calculateSupport(perm);
        
        // 4. Adjacency
        const dist = Math.abs(img - sourcePoint);
        const adjacencyPenalty = (dist === 1) ? 0 : (dist * 100);

        return orderPenalty + (support * 10) + adjacencyPenalty;
    };

    let pool = [];
    const seenIds = new Set();
    
    const tryAdd = (id) => {
        if (seenIds.has(id)) return;
        seenIds.add(id);
        let s = evaluate(id);
        // Heuristic: Keep good mixers even if they miss target
        if (s > 1e6) {
            const ord = calcApproxOrder(globalRepo.get(id));
            if (ord === 2) s = 5000;
            else if (ord &lt; 5) s = 10000;
        }
        pool.push({ id, score: s });
    };

    genIds.forEach(id => {
        tryAdd(id);
        tryAdd(globalRepo.inverse(id));
        tryAdd(globalRepo.multiply(id, id));
    });

    if (pool.length === 0) return -1;
    pool.sort((a, b) => a.score - b.score);

    if (pool[0].score &lt; 100) return pool[0].id;

    for (let gen = 0; gen &lt; maxGenerations; gen++) {
        const nextGenCandidates = [];
        const breeders = pool.slice(0, Math.min(pool.length, beamWidth));
        
        // Mixing
        for (let i = 0; i &lt; breeders.length; i++) {
            for (let j = 0; j &lt; breeders.length; j++) {
                if (i === j) continue;
                nextGenCandidates.push(globalRepo.multiply(breeders[i].id, breeders[j].id));
            }
        }

        // Conjugation
        const involutions = breeders.filter(b => calcApproxOrder(globalRepo.get(b.id)) === 2);
        const sources = involutions.length > 0 ? involutions : breeders;
        
        for (const b of breeders) {
            const g = b.id;
            const gInv = globalRepo.inverse(g);
            for (const h of sources) {
                const tmp = globalRepo.multiply(g, h.id);
                nextGenCandidates.push(globalRepo.multiply(tmp, gInv));
            }
        }

        for (const cid of nextGenCandidates) tryAdd(cid);

        pool.sort((a, b) => a.score - b.score);
        pool = pool.slice(0, beamWidth);

        if (pool[0].score &lt; 100) return pool[0].id;
    }

    return (pool[0].score &lt; 1e6) ? pool[0].id : -1;
}
/**
 * Performs a random walk in the group to find an involution mapping sourcePoint to validDestinations.
 * @private
 */
function _randomWalkForInvolution(genIds, sourcePoint, validDestinations, maxSteps) {
    if (genIds.length === 0) return -1;
    let pool = [...genIds];
    genIds.forEach(id => pool.push(globalRepo.inverse(id)));
    const seen = new Set(pool);

    for (let i = 0; i &lt; maxSteps; i++) {
        const a = pool[Math.floor(Math.random() * pool.length)];
        const b = pool[Math.floor(Math.random() * pool.length)];
        const prod = globalRepo.multiply(a, b);
        
        if (!seen.has(prod)) {
            pool.push(prod);
            seen.add(prod);
            if (pool.length > 300) {
                pool.splice(0, 100); 
                seen.clear(); pool.forEach(x=>seen.add(x));
            }
        }

        const perm = globalRepo.get(prod);
        const ord = calcApproxOrder(perm);
        if (ord === 2) {
            const img = (sourcePoint &lt; perm.length) ? perm[sourcePoint] : sourcePoint;
            if (validDestinations.has(img)) return prod;
        }
    }
    return -1;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Tue Feb 03 2026 12:25:57 GMT+0800 (中国标准时间) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
